<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Congressional Co-sponsorship Network</title>
    <style>
        body {
            background-color: #2a2a2a;
            margin: 0;
            color: white;
            font-family: Arial, sans-serif;
        }
        svg {
            width: 100%;
            height: 95vh;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
            fill: white;
            stroke: black;
            stroke-width: 0.8px;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .controls button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }
        .controls button:hover {
            background: #666;
        }
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 12px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="loadData()">RESET</button>
        <button onclick="stabilize()">STABILIZE</button>
        <button onclick="fitView()">FIT VIEW</button>
        <button onclick="togglePhysics()">TOGGLE PHYSICS</button>
        <button onclick="clearSelection()">CLEAR</button>
    </div>
    
    <div class="stats">
        <div>Nodes: <span id="node-count">0</span></div>
        <div>Edges: <span id="edge-count">0</span></div>
        <div>Democrats: <span id="dem-count">0</span></div>
        <div>Republicans: <span id="rep-count">0</span></div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #0066cc;"></div>
            <span>Democrats</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #cc0000;"></div>
            <span>Republicans</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #666666;"></div>
            <span>Other</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6666;"></div>
            <span>Selected</span>
        </div>
    </div>

    <svg></svg>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let selectedMember = null;
        let fullData = null;
        let currentFocus = null;
        let physicsEnabled = true;
        let simulation = null;
        
        const svg = d3.select("svg");
        const width = window.innerWidth;
        const height = window.innerHeight;
        const zoom = d3.zoom().scaleExtent([0.1, 10]).on("zoom", zoomed);
        const container = svg.append("g");
        svg.call(zoom);

        function zoomed({transform}) {
            container.attr("transform", transform);
        }

        function loadData() {
            // Clear selected member
            selectedMember = null;
            currentFocus = null;

            fetch('/api/network/cosponsorship')
                .then(res => res.json())
                .then(data => {
                    fullData = data;
                    currentFocus = null;
                    render(data, null);
                })
                .catch(error => {
                    console.error('Error loading network data:', error);
                });
        }

        function render({nodes, edges}, clickedId) {
            container.selectAll("*").remove();
            
            // Stop any existing simulation
            if (simulation) {
                simulation.stop();
            }
            
            // Create a set of valid node IDs for quick lookup
            const validNodeIds = new Set(nodes.map(n => n.id));
            
            // Convert edges to D3 format, filtering out edges with invalid nodes
            const invalidEdges = edges.filter(edge => !validNodeIds.has(edge.from) || !validNodeIds.has(edge.to));
            if (invalidEdges.length > 0) {
                console.warn(`Filtered out ${invalidEdges.length} edges with invalid nodes:`, 
                    invalidEdges.map(e => ({from: e.from, to: e.to})));
            }
            
            const links = edges
                .filter(edge => validNodeIds.has(edge.from) && validNodeIds.has(edge.to))
                .map(edge => ({
                    source: edge.from,
                    target: edge.to,
                    weight: edge.value || 1,
                    title: edge.title
                }));
        
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("x", d3.forceX(width / 2).strength(0.05))
                .force("y", d3.forceY(height / 2).strength(0.05))
                .force("collide", d3.forceCollide(15))
                .force("center", d3.forceCenter(width / 2, height / 2));
            
            if (!physicsEnabled) {
                simulation.stop();
            }
        
            const connectedIds = new Set();
            if (clickedId) {
                connectedIds.add(clickedId);
                links.forEach(l => {
                    if (l.source.id === clickedId || l.target.id === clickedId) {
                        connectedIds.add(l.source.id);
                        connectedIds.add(l.target.id);
                    }
                });
            }
        
            const linkGroup = container.append("g").attr("stroke-opacity", 0.4);
            const nodeGroup = container.append("g").attr("stroke-width", 1.5);
        
            const link = linkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", 1) // Fixed small width
                .attr("stroke", d =>
                    clickedId && (d.source.id === clickedId || d.target.id === clickedId)
                        ? "#ff6666"
                        : "#666"
                );
        
            const node = nodeGroup.selectAll("g")
                .data(nodes)
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstart)
                    .on("drag", dragged)
                    .on("end", dragend));
            
            node.append("circle")
                .attr("r", 8) // Fixed small size
                .attr("fill", d => {
                    if (!clickedId) return d.color;
                    if (d.id === clickedId) return "#ff6666";
                    return connectedIds.has(d.id) ? d.color : "#333";
                });
            
            node.append("title")
                .text(d => `${d.label} (${d.party}-${d.state}-${d.district})`);
            
            node.append("text")
                .text(d => d.label.split(' ').pop()) // Show last name only
                .attr("x", 12)
                .attr("y", 3)
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", 0.3)
                .style("font", "bold 12px Arial")
                .style("font-weight", "900");
            
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
            
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });
            
            node.on("click", (_, clickedNode) => {
                if (currentFocus && currentFocus.id === clickedNode.id) {
                    currentFocus = null;
                    selectedMember = null;
                    render(fullData, null);
                    return;
                }
            
                currentFocus = clickedNode;
                selectedMember = clickedNode.label;
            
                const connected = new Set([clickedNode.id]);
                const connectedLinks = links.filter(
                    l => l.source.id === clickedNode.id || l.target.id === clickedNode.id
                );
                connectedLinks.forEach(l => {
                    connected.add(l.source.id);
                    connected.add(l.target.id);
                });
            
                const newNodes = nodes.filter(n => connected.has(n.id));
                const newLinks = links.filter(
                    l => connected.has(l.source.id) && connected.has(l.target.id)
                );
            
                render({nodes: newNodes, links: newLinks}, clickedNode.id);
            
                setTimeout(() => {
                    const positions = newNodes.map(d => [d.x, d.y]);
                    const xExtent = d3.extent(positions, p => p[0]);
                    const yExtent = d3.extent(positions, p => p[1]);
            
                    const paddingX = 60;
                    const paddingY = 100;
                    const boxWidth = xExtent[1] - xExtent[0] + paddingX * 2;
                    const boxHeight = yExtent[1] - yExtent[0] + paddingY * 2;
            
                    const scale = Math.min(width / boxWidth, height / boxHeight, 4);
                    const xCenter = (xExtent[0] + xExtent[1]) / 2;
                    const yCenter = (yExtent[0] + yExtent[1]) / 2;
            
                    const transform = d3.zoomIdentity
                        .translate(width / 2, height / 2)
                        .scale(scale)
                        .translate(-xCenter, -yCenter);
            
                    svg.transition().duration(750).call(zoom.transform, transform);
                }, 300);
            });
            
            updateStats(nodes, links);
        }
        
        function updateStats(nodes, links) {
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('edge-count').textContent = links.length;
            
            const demCount = nodes.filter(n => n.party === 'D').length;
            const repCount = nodes.filter(n => n.party === 'R').length;
            
            document.getElementById('dem-count').textContent = demCount;
            document.getElementById('rep-count').textContent = repCount;
        }
        
        function stabilize() {
            if (fullData) {
                render(fullData, currentFocus ? currentFocus.id : null);
            }
        }
        
        function fitView() {
            if (fullData) {
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(0.8);
                svg.transition().duration(750).call(zoom.transform, transform);
            }
        }
        
        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            if (fullData) {
                render(fullData, currentFocus ? currentFocus.id : null);
            }
        }
        
        function clearSelection() {
            if (fullData) {
                currentFocus = null;
                selectedMember = null;
                render(fullData, null);
            }
        }
        
        function dragstart(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = d.y;
        }
        
        function dragend(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            svg.attr('width', newWidth).attr('height', newHeight);
        });
        
        // Load data when page loads
        loadData();
    </script>
</body>
</html>
