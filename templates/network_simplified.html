<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Simplified Co-sponsorship Network</title>
    <style>
        body {
            background-color: #2a2a2a;
            margin: 0;
            color: white;
            font-family: Arial, sans-serif;
        }
        svg {
            width: 100%;
            height: 85vh;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
            fill: white;
            stroke: black;
            stroke-width: 0.8px;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            min-width: 250px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .control-group input, .control-group select {
            width: 100%;
            padding: 4px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
        }
        .controls button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 6px 12px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .controls button:hover {
            background: #666;
        }
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 12px;
            min-width: 150px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #333;
        }
        .filter-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 11px;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Network Filters</h3>
        
        <div class="control-group">
            <label for="min-relationships">Min Co-sponsorships:</label>
            <input type="number" id="min-relationships" value="3" min="1" max="20">
        </div>
        
        <div class="control-group">
            <label for="min-bills-sponsored">Min Bills Sponsored:</label>
            <input type="number" id="min-bills-sponsored" value="1" min="0" max="50">
        </div>
        
        <div class="control-group">
            <label for="max-edges-per-node">Max Edges per Node:</label>
            <input type="number" id="max-edges-per-node" value="20" min="5" max="50">
        </div>
        
        <div class="control-group">
            <label for="party-filter">Party Filter:</label>
            <select id="party-filter">
                <option value="">All Parties</option>
                <option value="D">Democrats Only</option>
                <option value="R">Republicans Only</option>
            </select>
        </div>
        
        <button onclick="applyFilters()">Apply Filters</button>
        <button onclick="resetFilters()">Reset</button>
        <button onclick="stabilize()">Stabilize</button>
        <button onclick="fitView()">Fit View</button>
        <button onclick="togglePhysics()">Toggle Physics</button>
    </div>
    
    <div class="stats">
        <div><strong>Network Stats:</strong></div>
        <div>Nodes: <span id="node-count">0</span></div>
        <div>Edges: <span id="edge-count">0</span></div>
        <div>Democrats: <span id="dem-count">0</span></div>
        <div>Republicans: <span id="rep-count">0</span></div>
        <div>Filtered from: <span id="total-edges">0</span></div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #0066cc;"></div>
            <span>Democrats</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #cc0000;"></div>
            <span>Republicans</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #666666;"></div>
            <span>Other</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6666;"></div>
            <span>Selected</span>
        </div>
    </div>
    
    <div class="filter-info">
        <div><strong>Current Filters:</strong></div>
        <div id="filter-summary">Loading...</div>
    </div>

    <svg></svg>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let selectedMember = null;
        let fullData = null;
        let currentFocus = null;
        let physicsEnabled = true;
        let currentFilters = {};
        let simulation = null;
        
        const svg = d3.select("svg");
        const width = window.innerWidth;
        const height = window.innerHeight;
        const zoom = d3.zoom().scaleExtent([0.1, 10]).on("zoom", zoomed);
        const container = svg.append("g");
        svg.call(zoom);

        function zoomed({transform}) {
            container.attr("transform", transform);
        }

        function getFilterParams() {
            return {
                min_relationships: parseInt(document.getElementById('min-relationships').value),
                min_bills_sponsored: parseInt(document.getElementById('min-bills-sponsored').value),
                max_edges_per_node: parseInt(document.getElementById('max-edges-per-node').value),
                party: document.getElementById('party-filter').value
            };
        }

        function loadData() {
            // Clear selected member
            selectedMember = null;
            currentFocus = null;

            const params = getFilterParams();
            const queryString = new URLSearchParams(params).toString();
            
            fetch(`/api/network/cosponsorship/simplified?${queryString}`)
                .then(res => res.json())
                .then(data => {
                    fullData = data;
                    currentFocus = null;
                    currentFilters = data.filters;
                    render(data, null);
                    updateFilterSummary(data);
                })
                .catch(error => {
                    console.error('Error loading network data:', error);
                });
        }

        function updateFilterSummary(data) {
            const summary = document.getElementById('filter-summary');
            const stats = data.stats;
            summary.innerHTML = `
                Min relationships: ${data.filters.min_relationships}<br>
                Min bills sponsored: ${data.filters.min_bills_sponsored}<br>
                Max edges per node: ${data.filters.max_edges_per_node}<br>
                Party filter: ${data.filters.party_filter || 'All'}<br>
                <br>
                <strong>Results:</strong><br>
                ${stats.active_members}/${stats.total_members} members<br>
                ${stats.filtered_edges}/${stats.total_edges} edges shown
            `;
        }

        function applyFilters() {
            loadData();
        }

        function resetFilters() {
            document.getElementById('min-relationships').value = 3;
            document.getElementById('min-bills-sponsored').value = 1;
            document.getElementById('max-edges-per-node').value = 20;
            document.getElementById('party-filter').value = '';
            loadData();
        }

        function render({nodes, edges}, clickedId) {
            container.selectAll("*").remove();
            
            // Stop any existing simulation
            if (simulation) {
                simulation.stop();
            }
            
            // Create a set of valid node IDs for quick lookup
            const validNodeIds = new Set(nodes.map(n => n.id));
            
            // Convert edges to D3 format, filtering out edges with invalid nodes
            const invalidEdges = edges.filter(edge => !validNodeIds.has(edge.from) || !validNodeIds.has(edge.to));
            if (invalidEdges.length > 0) {
                console.warn(`Filtered out ${invalidEdges.length} edges with invalid nodes:`, 
                    invalidEdges.map(e => ({from: e.from, to: e.to})));
            }
            
            const links = edges
                .filter(edge => validNodeIds.has(edge.from) && validNodeIds.has(edge.to))
                .map(edge => ({
                    source: edge.from,
                    target: edge.to,
                    weight: edge.value || 1,
                    title: edge.title
                }));
        
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("x", d3.forceX(width / 2).strength(0.05))
                .force("y", d3.forceY(height / 2).strength(0.05))
                .force("collide", d3.forceCollide(15))
                .force("center", d3.forceCenter(width / 2, height / 2));
            
            if (!physicsEnabled) {
                simulation.stop();
            }
        
            const connectedIds = new Set();
            if (clickedId) {
                connectedIds.add(clickedId);
                links.forEach(l => {
                    if (l.source.id === clickedId || l.target.id === clickedId) {
                        connectedIds.add(l.source.id);
                        connectedIds.add(l.target.id);
                    }
                });
            }
        
            const linkGroup = container.append("g").attr("stroke-opacity", 0.4);
            const nodeGroup = container.append("g").attr("stroke-width", 1.5);
        
            const link = linkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", 1) // Fixed small width
                .attr("stroke", d =>
                    clickedId && (d.source.id === clickedId || d.target.id === clickedId)
                        ? "#ff6666"
                        : "#666"
                );
        
            const node = nodeGroup.selectAll("g")
                .data(nodes)
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstart)
                    .on("drag", dragged)
                    .on("end", dragend));
            
            node.append("circle")
                .attr("r", 8) // Fixed small size
                .attr("fill", d => {
                    if (!clickedId) return d.color;
                    if (d.id === clickedId) return "#ff6666";
                    return connectedIds.has(d.id) ? d.color : "#333";
                });
            
            node.append("title")
                .text(d => d.title);
            
            node.append("text")
                .text(d => d.label.split(' ').pop()) // Show last name only
                .attr("x", 12)
                .attr("y", 3)
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", 0.3)
                .style("font", "bold 12px Arial")
                .style("font-weight", "900");
            
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
            
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });
            
            node.on("click", (_, clickedNode) => {
                if (currentFocus && currentFocus.id === clickedNode.id) {
                    currentFocus = null;
                    selectedMember = null;
                    render(fullData, null);
                    return;
                }
            
                currentFocus = clickedNode;
                selectedMember = clickedNode.label;
            
                const connected = new Set([clickedNode.id]);
                const connectedLinks = links.filter(
                    l => l.source.id === clickedNode.id || l.target.id === clickedNode.id
                );
                connectedLinks.forEach(l => {
                    connected.add(l.source.id);
                    connected.add(l.target.id);
                });
            
                const newNodes = nodes.filter(n => connected.has(n.id));
                const newLinks = links.filter(
                    l => connected.has(l.source.id) && connected.has(l.target.id)
                );
            
                render({nodes: newNodes, links: newLinks}, clickedNode.id);
            
                setTimeout(() => {
                    const positions = newNodes.map(d => [d.x, d.y]);
                    const xExtent = d3.extent(positions, p => p[0]);
                    const yExtent = d3.extent(positions, p => p[1]);
            
                    const paddingX = 60;
                    const paddingY = 100;
                    const boxWidth = xExtent[1] - xExtent[0] + paddingX * 2;
                    const boxHeight = yExtent[1] - yExtent[0] + paddingY * 2;
            
                    const scale = Math.min(width / boxWidth, height / boxHeight, 4);
                    const xCenter = (xExtent[0] + xExtent[1]) / 2;
                    const yCenter = (yExtent[0] + yExtent[1]) / 2;
            
                    const transform = d3.zoomIdentity
                        .translate(width / 2, height / 2)
                        .scale(scale)
                        .translate(-xCenter, -yCenter);
            
                    svg.transition().duration(750).call(zoom.transform, transform);
                }, 300);
            });
            
            updateStats(nodes, links, fullData.stats);
        }
        
        function updateStats(nodes, links, stats) {
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('edge-count').textContent = links.length;
            document.getElementById('total-edges').textContent = stats.total_edges;
            
            const demCount = nodes.filter(n => n.party === 'D').length;
            const repCount = nodes.filter(n => n.party === 'R').length;
            
            document.getElementById('dem-count').textContent = demCount;
            document.getElementById('rep-count').textContent = repCount;
        }
        
        function stabilize() {
            if (fullData) {
                render(fullData, currentFocus ? currentFocus.id : null);
            }
        }
        
        function fitView() {
            if (fullData) {
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(0.8);
                svg.transition().duration(750).call(zoom.transform, transform);
            }
        }
        
        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            if (fullData) {
                render(fullData, currentFocus ? currentFocus.id : null);
            }
        }
        
        function dragstart(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragend(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            svg.attr('width', newWidth).attr('height', newHeight);
        });
        
        // Load data when page loads
        loadData();
    </script>
</body>
</html>
