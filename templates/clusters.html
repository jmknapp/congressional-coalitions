<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Member Clusters</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    .legend-swatch{display:inline-block;width:12px;height:12px;border-radius:2px;margin-right:6px}
    .point{cursor:pointer}
    .tooltip-card{position:absolute; pointer-events:none; z-index:1000; background:#fff; border:1px solid #ddd; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); padding:8px 10px; display:none; min-width:220px}
    .tooltip-card img{width:64px; height:64px; object-fit:cover; border-radius:4px; margin-right:10px}
    .tooltip-card .title{font-weight:600}
    .tooltip-card .sub{color:#666; font-size:0.9em}
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container">
      <a class="navbar-brand" href="/"><i class="bi bi-bank"></i> 119th Congress Analysis</a>
      <div class="navbar-nav ms-auto">
        <a class="nav-link" href="/docs">Docs</a>
      </div>
    </div>
  </nav>

  <div class="container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h3>Vote Pattern Clusters</h3>
      <div class="d-flex gap-2">
        <select id="svdDims" class="form-select form-select-sm" style="width:120px">
          <option value="2">SVD(2)</option>
          <option value="3" selected>SVD(3)</option>
        </select>
        <input id="subject" class="form-control form-control-sm" style="width:220px; display:none" placeholder="Subject term(s); comma-separated"/>
        <select id="subjectTerm" class="form-select form-select-sm" style="width:220px; display:none">
          <option value="">All subject terms</option>
        </select>
        <select id="policyArea" class="form-select form-select-sm" style="width:220px; display:none">
          <option value="">All policy areas</option>
        </select>
        <select id="scope" class="form-select form-select-sm" style="width:150px">
          <option value="policy_area">Policy Area</option>
          <option value="subject_term" selected>Subject Term</option>
        </select>
        <select id="k" class="form-select form-select-sm" style="width:120px">
          <option value="2">k=2</option>
          <option value="3">k=3</option>
          <option value="4">k=4</option>
          <option value="5">k=5</option>
          <option value="6">k=6</option>
          <option value="7">k=7</option>
          <option value="8">k=8</option>
          <option value="9">k=9</option>
          <option value="10">k=10</option>
        </select>
        <button id="btnSuggestK" class="btn btn-sm btn-outline-primary">Suggest k</button>
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="excludeProcedural" checked>
          <label class="form-check-label" for="excludeProcedural">Exclude procedural</label>
        </div>
        <button id="refresh" class="btn btn-sm btn-primary">Refresh</button>
        <button id="reset" class="btn btn-sm btn-outline-secondary">Reset</button>
        <button id="generateReport" class="btn btn-sm btn-success">Generate Report</button>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-9 mb-3">
        <div class="alert alert-info alert-dismissible fade show" id="mouseControlsInfo" role="alert">
          <i class="fas fa-info-circle"></i>
          <strong>Mouse Controls:</strong> <span id="mouseControlsText">Drag to pan • Shift+drag to adjust rotation • Mouse wheel to zoom • Double-click to reset view</span>
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close" onclick="closeMouseControlsInfo()"></button>
        </div>
        <div class="border rounded p-2">
          <svg id="plot" viewBox="0 0 800 600" style="width:100%;height:auto"></svg>
        </div>
      </div>
      <div class="col-lg-3">
        <div class="card mb-3">
          <div class="card-body">
            <h6 class="mb-2">Legend</h6>
            <div id="legend"></div>
            <hr>
            <div class="form-check">
              <input class="form-check-input" type="radio" name="colorBy" id="colorByParty" value="party" checked>
              <label class="form-check-label" for="colorByParty">Color by party</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="radio" name="colorBy" id="colorByCluster" value="cluster">
              <label class="form-check-label" for="colorByCluster">Color by cluster</label>
            </div>
            <hr>
            <div class="mb-2">Axis details</div>
            <div class="d-flex gap-2 align-items-center mb-2">
              <select id="axisSelect" class="form-select form-select-sm" style="width:120px">
                <option value="1" selected>Axis 1</option>
                <option value="2">Axis 2</option>
                <option value="3">Axis 3</option>
              </select>
              <button id="btnDescribeAxis" class="btn btn-sm btn-outline-secondary">Describe</button>
            </div>
            <div id="axis-summary" class="small"></div>
          </div>
        </div>
        <div class="card">
          <div class="card-body small text-muted">
            <div id="k-metrics" class="small"></div>
            <hr>
            <div class="mb-2">Cluster details</div>
            <div class="d-flex gap-2 align-items-center mb-2">
              <select id="clusterSelect" class="form-select form-select-sm" style="width:120px">
                <option value="0" selected>Cluster 1</option>
                <option value="1">Cluster 2</option>
                <option value="2">Cluster 3</option>
                <option value="3">Cluster 4</option>
                <option value="4">Cluster 5</option>
                <option value="5">Cluster 6</option>
                <option value="6">Cluster 7</option>
                <option value="7">Cluster 8</option>
                <option value="8">Cluster 9</option>
                <option value="9">Cluster 10</option>
              </select>
              <button id="btnDescribeCluster" class="btn btn-sm btn-outline-secondary">Describe cluster</button>
            </div>
            <div id="cluster-summary" class="small"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // tooltip element
    const tip = document.createElement('div');
    tip.className = 'tooltip-card';
    document.body.appendChild(tip);

    // zoom/pan state
    const VB_W = 800, VB_H = 600;
    let zScale = 1.0, zTx = 0, zTy = 0; // transform in viewBox units
    let isPanning = false, panLast = {x:0,y:0};
    // rotation state for SVD(3)
    let isRotating = false, rotLast = {x:0,y:0};
    let yawDeg = 35, pitchDeg = 20; // defaults; shift+drag adjusts these
    // normalized zero positions for axes from API
    let normZeros = {x0:0.5, y0:0.5, z0:0.5};
    let svdComponents = null;
    function updateTransform(){
      const content = document.getElementById('content');
      if (content) content.setAttribute('transform', `translate(${zTx},${zTy}) scale(${zScale})`);
    }

    const partyColors = { 'D': '#2b6cb0', 'R': '#c53030', 'I': '#718096', '': '#718096', null: '#718096', undefined: '#718096' };
    function clusterColor(idx){
      const palette = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
      return palette[idx % palette.length];
    }

    async function load(useSuggestedK = false) {
      let k = document.getElementById('k').value;
      
      // If this is the initial load and no k is selected, get the suggested k
      if (useSuggestedK && !document.getElementById('k').value) {
        const excludeProcedural = document.getElementById('excludeProcedural').checked;
        const scope = document.getElementById('scope').value;
        const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
        
        try {
          const autoKUrl = `/api/clusters/auto-k?exclude_procedural=${excludeProcedural}` +
                          (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
          const autoKRes = await fetch(autoKUrl);
          if (autoKRes.ok) {
            const autoKData = await autoKRes.json();
            if (autoKData.suggested_k) {
              k = autoKData.suggested_k;
              document.getElementById('k').value = k;
            }
          }
        } catch (error) {
          console.warn('Could not get suggested k, using default k=5:', error);
          k = '5';
          document.getElementById('k').value = k;
        }
      }
      
      const excludeProcedural = document.getElementById('excludeProcedural').checked;
      const scope = document.getElementById('scope').value;
      const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
      const url = `/api/clusters?k=${k}&exclude_procedural=${excludeProcedural}` +
                  (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
      const res = await fetch(url);
      if (!res.ok) {
        const text = await res.text();
        alert(`API error (${res.status}):\n${text}`);
        return;
      }
      const data = await res.json();
      if (data.norm_zeros) normZeros = data.norm_zeros;
      
      // Fetch SVD components for axis labels
      const dims = document.getElementById('svdDims').value || '2';
      try {
        const svdUrl = `/api/svd/components?dims=${dims}&exclude_procedural=${excludeProcedural}` +
                      (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
        const svdRes = await fetch(svdUrl);
        if (svdRes.ok) {
          const svdData = await svdRes.json();
          svdComponents = svdData.components || [];
        }
      } catch (error) {
        console.warn('Could not fetch SVD components:', error);
        svdComponents = null;
      }
      
      render(data.items || []);
    }

    let currentItems = [];
    
    function render(items){
      currentItems = items;
      
      // Update cluster dropdown based on actual clusters in data
      updateClusterDropdown(items);
      
      const svg = document.getElementById('plot');
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      const w=800,h=600, pad=30;
      // content group for zoom/pan
      const content = document.createElementNS('http://www.w3.org/2000/svg','g');
      content.setAttribute('id','content');
      svg.appendChild(content);
      // axes
      const axes = document.createElementNS('http://www.w3.org/2000/svg','g');
      axes.innerHTML = `<line x1="${pad}" y1="${h-pad}" x2="${w-pad}" y2="${h-pad}" stroke="#ddd"/>\n                        <line x1="${pad}" y1="${pad}" x2="${pad}" y2="${h-pad}" stroke="#ddd"/>`;
      content.appendChild(axes);

      // principal axes through SVD zero (if provided)
      const dimsAxes = parseInt(document.getElementById('svdDims').value||'2',10);
      const axes0 = document.createElementNS('http://www.w3.org/2000/svg','g');
      axes0.setAttribute('opacity','0.9');
      const x0n = (normZeros?.x0 ?? 0.5);
      const y0n = (normZeros?.y0 ?? 0.5);
      const z0n = (normZeros?.z0 ?? 0.5);
      if (dimsAxes === 2){
        const vx = pad + x0n*(w-2*pad);
        const vy = pad + (1-y0n)*(h-2*pad);
        const vline = document.createElementNS('http://www.w3.org/2000/svg','line');
        vline.setAttribute('x1', vx); vline.setAttribute('x2', vx);
        vline.setAttribute('y1', pad); vline.setAttribute('y2', h-pad);
        vline.setAttribute('stroke', '#aaa'); vline.setAttribute('stroke-dasharray', '4,3');
        const hline = document.createElementNS('http://www.w3.org/2000/svg','line');
        hline.setAttribute('x1', pad); hline.setAttribute('x2', w-pad);
        hline.setAttribute('y1', vy); hline.setAttribute('y2', vy);
        hline.setAttribute('stroke', '#aaa'); hline.setAttribute('stroke-dasharray', '4,3');
        axes0.appendChild(vline); axes0.appendChild(hline);
        // axis labels with characterizations oriented along axes
        const labelText1 = svdComponents && svdComponents[0] ? 
          `1: ${generateAxisCharacterization(svdComponents[0])}` : '1';
        const labelText2 = svdComponents && svdComponents[1] ? 
          `2: ${generateAxisCharacterization(svdComponents[1])}` : '2';
        
        // X-axis label (vertical line) - positioned along the top of the axis
        const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t1.setAttribute('x', vx + 8); t1.setAttribute('y', pad + 8);
        t1.setAttribute('fill', '#888'); t1.setAttribute('font-size', '11'); 
        t1.setAttribute('text-anchor', 'start');
        t1.textContent = labelText1;
        axes0.appendChild(t1);
        
        // Y-axis label (horizontal line) - positioned along the right side of the axis
        const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t2.setAttribute('x', w - pad - 8); t2.setAttribute('y', vy - 8);
        t2.setAttribute('fill', '#888'); t2.setAttribute('font-size', '11'); 
        t2.setAttribute('text-anchor', 'end');
        t2.textContent = labelText2;
        axes0.appendChild(t2);
      } else {
        const yaw = yawDeg * Math.PI/180, pitch = pitchDeg * Math.PI/180;
        function proj(nx, ny, nz){
          let x = (nx - 0.5), y = (ny - 0.5), z = (nz - 0.5);
          let y1 = y*Math.cos(pitch) - z*Math.sin(pitch);
          let z1 = y*Math.sin(pitch) + z*Math.cos(pitch);
          let x2 = x*Math.cos(yaw) + z1*Math.sin(yaw);
          const sx = pad + (x2+0.5)*(w-2*pad);
          const sy = pad + (0.5 - y1)*(h-2*pad);
          return {x:sx, y:sy};
        }
        const p0 = proj(x0n,y0n,z0n);
        const px = proj(1,y0n,z0n);
        const py = proj(x0n,1,z0n);
        const pz = proj(x0n,y0n,1);
        function addLine(a,b,color){
          const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
          ln.setAttribute('x1', a.x); ln.setAttribute('y1', a.y);
          ln.setAttribute('x2', b.x); ln.setAttribute('y2', b.y);
          ln.setAttribute('stroke', color); ln.setAttribute('stroke-dasharray','4,3');
          axes0.appendChild(ln);
        }
        addLine(p0, px, '#a66'); // X axis
        addLine(p0, py, '#6a6'); // Y axis
        addLine(p0, pz, '#66a'); // Z axis
        // Calculate axis direction vectors for label positioning
        const dx = {x: px.x - p0.x, y: px.y - p0.y};
        const dy = {x: py.x - p0.x, y: py.y - p0.y};
        const dz = {x: pz.x - p0.x, y: pz.y - p0.y};
        
        // Normalize direction vectors
        const len = (v) => Math.sqrt(v.x*v.x + v.y*v.y);
        const normalize = (v) => {
          const l = len(v);
          return l > 0 ? {x: v.x/l, y: v.y/l} : {x: 0, y: 0};
        };
        
        const dxn = normalize(dx);
        const dyn = normalize(dy);
        const dzn = normalize(dz);
        
        // Position labels along axis directions, offset from the axis endpoints
        const offset = 15;
        
        // X-axis label
        const labelX = svdComponents && svdComponents[0] ? 
          `1: ${generateAxisCharacterization(svdComponents[0])}` : '1';
        const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t1.setAttribute('x', px.x + dxn.x * offset); 
        t1.setAttribute('y', px.y + dxn.y * offset);
        t1.setAttribute('fill', '#a66'); t1.setAttribute('font-size', '11'); 
        t1.setAttribute('text-anchor', 'middle');
        t1.textContent = labelX;
        axes0.appendChild(t1);
        
        // Y-axis label
        const labelY = svdComponents && svdComponents[1] ? 
          `2: ${generateAxisCharacterization(svdComponents[1])}` : '2';
        const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t2.setAttribute('x', py.x + dyn.x * offset); 
        t2.setAttribute('y', py.y + dyn.y * offset);
        t2.setAttribute('fill', '#6a6'); t2.setAttribute('font-size', '11'); 
        t2.setAttribute('text-anchor', 'middle');
        t2.textContent = labelY;
        axes0.appendChild(t2);
        
        // Z-axis label
        const labelZ = svdComponents && svdComponents[2] ? 
          `3: ${generateAxisCharacterization(svdComponents[2])}` : '3';
        const t3 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t3.setAttribute('x', pz.x + dzn.x * offset); 
        t3.setAttribute('y', pz.y + dzn.y * offset);
        t3.setAttribute('fill', '#66a'); t3.setAttribute('font-size', '11'); 
        t3.setAttribute('text-anchor', 'middle');
        t3.textContent = labelZ;
        axes0.appendChild(t3);
      }
      content.appendChild(axes0);

      const colorBy = document.querySelector('input[name="colorBy"]:checked').value;
      const makeColor = (d)=> colorBy==='party' ? partyColors[(d.party||'').substring(0,1).toUpperCase()] : clusterColor(d.cluster);

      const dimsPlot = parseInt(document.getElementById('svdDims').value||'2',10);
      const yaw = yawDeg * Math.PI/180, pitch = pitchDeg * Math.PI/180; // current 3D view
      function project(d){
        if (dimsPlot !== 3 || d.z === null || d.z === undefined) {
          return {x: pad + d.x*(w-2*pad), y: pad + (1-d.y)*(h-2*pad)};
        }
        // 3D point in [0,1]^3 mapped to centered coordinates then rotated
        let x = (d.x - 0.5), y = (d.y - 0.5), z = (d.z - 0.5);
        // rotate around X (pitch)
        let y1 = y*Math.cos(pitch) - z*Math.sin(pitch);
        let z1 = y*Math.sin(pitch) + z*Math.cos(pitch);
        // rotate around Y (yaw)
        let x2 = x*Math.cos(yaw) + z1*Math.sin(yaw);
        let z2 = -x*Math.sin(yaw) + z1*Math.cos(yaw);
        // map back to [0,1] with some depth scaling (optional)
        const sx = pad + (x2+0.5)*(w-2*pad);
        const sy = pad + (0.5 - y1)*(h-2*pad);
        return {x:sx, y:sy, depth:z2};
      }

      items.forEach(d=>{
        const p = project(d);
        const cx = p.x;
        const cy = p.y;
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('cx',cx);
        circ.setAttribute('cy',cy);
        circ.setAttribute('r',4);
        circ.setAttribute('fill', makeColor(d));
        circ.setAttribute('class','point');
        // custom tooltip
        circ.addEventListener('mouseenter', (e)=>{
          const imgUrl = `/api/member-image/${d.id}`;
          const state = d.state ? d.state : '';
          const district = (d.district!==null && d.district!==undefined) ? `-${d.district}` : '';
          // badges
          const b = d.badges || {};
          const badgeSpans = [];
          if (b.fc) badgeSpans.push('<span class="badge fc-pink-badge me-1 mb-1"><i class="fas fa-scale-unbalanced me-1"></i>FC</span>');
          if (b.pc) badgeSpans.push('<span class="badge bg-info text-white me-1 mb-1"><i class="fas fa-arrow-trend-up me-1"></i>PC</span>');
          if (b.bd) badgeSpans.push('<span class="badge bg-info text-white me-1 mb-1"><i class="fas fa-dog me-1"></i>BD</span>');
          if (b.maga) badgeSpans.push('<span class="badge bg-danger text-white me-1 mb-1"><i class="fas fa-biohazard me-1"></i>MAGA</span>');
          if (b.cbc) badgeSpans.push('<span class="badge text-white me-1 mb-1" style="background-color: #1a237e;"><i class="fas fa-users me-1"></i>CBC</span>');
          if (b.tb) badgeSpans.push('<span class="badge bg-primary text-white me-1 mb-1"><i class="fas fa-heart me-1"></i>TB</span>');
          const badgesHtml = badgeSpans.length ? `<div class="mt-1">${badgeSpans.join(' ')}</div>` : '';
          tip.innerHTML = `
            <div class="d-flex align-items-center">
              <img src="${imgUrl}" alt="${d.name}">
              <div>
                <div class="title">${d.name}</div>
                <div class="sub">${(d.party||'').toUpperCase()} ${state}${district}</div>
                <div class="sub">Cluster ${d.cluster}</div>
                ${badgesHtml}
              </div>
            </div>
          `;
          tip.style.display='block';
        });
        circ.addEventListener('mousemove', (e)=>{
          tip.style.left = (e.pageX + 12) + 'px';
          tip.style.top = (e.pageY + 12) + 'px';
        });
        circ.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
        content.appendChild(circ);
      });
      // apply existing zoom/pan after re-render
      updateTransform();

      // legend
      const legend = document.getElementById('legend');
      legend.innerHTML='';
      if (document.querySelector('input[name="colorBy"]:checked').value==='party'){
        legend.innerHTML = `
          <div><span class="legend-swatch" style="background:${partyColors['D']}"></span>Democratic</div>
          <div><span class="legend-swatch" style="background:${partyColors['R']}"></span>Republican</div>
          <div><span class="legend-swatch" style="background:${partyColors['I']}"></span>Other</div>`;
      } else {
        const clusters = [...new Set(items.map(d=>d.cluster))].sort((a,b)=>a-b);
        clusters.forEach(c=>{
          const div=document.createElement('div');
          div.innerHTML = `<span class="legend-swatch" style="background:${clusterColor(c)}"></span>Cluster ${c}`;
          legend.appendChild(div);
        });
      }
    }

    async function loadPolicyAreas(){
      const exclude = document.getElementById('excludeProcedural').checked;
      const res = await fetch(`/api/policy-areas?congress=119&chamber=house&exclude_procedural=${exclude}&min_votes=5`);
      if(!res.ok) return;
      const data = await res.json();
      const sel = document.getElementById('policyArea');
      sel.innerHTML = '<option value="">All policy areas</option>';
      (data.items || []).forEach(pa => {
        const opt = document.createElement('option');
        opt.value = pa.name; opt.textContent = `${pa.name} (${pa.count})`;
        sel.appendChild(opt);
      });
    }

    async function loadSubjectTerms(){
      const exclude = document.getElementById('excludeProcedural').checked;
      const res = await fetch(`/api/subject-terms?congress=119&chamber=house&exclude_procedural=${exclude}&min_votes=5`);
      if(!res.ok) return;
      const data = await res.json();
      const sel = document.getElementById('subjectTerm');
      sel.innerHTML = '<option value="">All subject terms</option>';
      (data.items || []).forEach(term => {
        const opt = document.createElement('option');
        opt.value = term.name; opt.textContent = `${term.name} (${term.count})`;
        sel.appendChild(opt);
      });
    }

    function toggleSubjectInputs(){
      const scope = document.getElementById('scope').value;
      const subj = document.getElementById('subject');
      const subjSel = document.getElementById('subjectTerm');
      const pa = document.getElementById('policyArea');
      if(scope === 'policy_area'){
        subj.style.display = 'none'; subjSel.style.display='none';
        pa.style.display = '';
        loadPolicyAreas();
      } else {
        subj.style.display = 'none';
        subjSel.style.display = '';
        pa.style.display = 'none';
        loadSubjectTerms();
      }
    }

    function updateMouseControlsInfo(){
      const svdDims = parseInt(document.getElementById('svdDims').value);
      const mouseControlsText = document.getElementById('mouseControlsText');
      
      if (svdDims === 3) {
        mouseControlsText.textContent = 'Drag to pan • Shift+drag to adjust rotation • Mouse wheel to zoom • Double-click to reset view';
      } else {
        mouseControlsText.textContent = 'Drag to pan • Mouse wheel to zoom • Double-click to reset view';
      }
    }

    function closeMouseControlsInfo(){
      const alert = document.getElementById('mouseControlsInfo');
      if (alert) {
        alert.style.display = 'none';
      }
    }

    function clearDescriptions(){
      // Clear axis and cluster descriptions when parameters change
      const axisSummary = document.getElementById('axis-summary');
      const clusterSummary = document.getElementById('cluster-summary');
      const kMetrics = document.getElementById('k-metrics');
      
      if (axisSummary) axisSummary.innerHTML = '';
      if (clusterSummary) clusterSummary.innerHTML = '';
      if (kMetrics) kMetrics.innerHTML = '';
    }

    function updateClusterDropdown(items) {
      // Get unique cluster IDs from the data
      const clusterIds = [...new Set(items.map(item => item.cluster))].sort((a, b) => a - b);
      
      const clusterSelect = document.getElementById('clusterSelect');
      if (!clusterSelect) return;
      
      // Clear existing options
      clusterSelect.innerHTML = '';
      
      // Add options for each cluster that exists (1-based numbering)
      clusterIds.forEach(clusterId => {
        const option = document.createElement('option');
        option.value = clusterId;
        option.textContent = `Cluster ${clusterId + 1}`; // Display as 1-based
        if (clusterId === 0) option.selected = true; // Default to first cluster (0 internally, 1 displayed)
        clusterSelect.appendChild(option);
      });
    }

    function generateAxisCharacterization(comp) {
      const posPA = comp.policy_area_pos || [];
      const negPA = comp.policy_area_neg || [];
      const posST = comp.subject_term_pos || [];
      const negST = comp.subject_term_neg || [];
      
      // Get top positive policy areas and subject terms
      const topPA = posPA.slice(0, 2).map(pa => pa.name).join('/');
      
      // Skip "Congressional Oversight" and use next subject term
      let filteredST = posST.filter(st => 
        !st.name.toLowerCase().includes('congressional oversight')
      );
      if (filteredST.length === 0) {
        filteredST = posST; // Fall back to original if all were filtered
      }
      const topST = filteredST.slice(0, 2).map(st => st.name).join('/');
      
      // Create characterization based on highest scoring items
      let characterization = '';
      
      if (topPA && topST) {
        // If we have both policy areas and subject terms, combine them
        const paWords = topPA.split('/')[0].split(' ')[0]; // First word of first policy area
        const st = topST.split('/')[0]; // First subject term
        
        // Use smart truncation for subject term
        let stWords = '';
        if (st.split(' ').length <= 3) {
          stWords = st;
        } else {
          // Look for natural break points
          const stWordsArray = st.split(' ');
          const breakWords = ['and', 'or', 'of', 'in', 'on', 'at', 'for', 'with', 'by'];
          let breakIndex = -1;
          
          for (let i = 2; i < Math.min(4, stWordsArray.length); i++) {
            if (breakWords.includes(stWordsArray[i].toLowerCase())) {
              breakIndex = i;
              break;
            }
          }
          
          if (breakIndex > 0) {
            stWords = stWordsArray.slice(0, breakIndex).join(' ');
          } else {
            stWords = stWordsArray.slice(0, 3).join(' ');
          }
        }
        
        characterization = `${paWords}/${stWords}`;
      } else if (topPA) {
        // Just use policy area
        characterization = topPA.split('/')[0];
      } else if (topST) {
        // Just use subject term
        characterization = topST.split('/')[0];
      } else {
        characterization = 'General';
      }
      
      // Clean up the characterization
      characterization = characterization
        .replace(/[^a-zA-Z0-9\s\/]/g, '') // Remove special characters
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      return characterization;
    }

    function generateClusterDescription(cluster) {
      const posPA = cluster.policy_area_pos || [];
      const negPA = cluster.policy_area_neg || [];
      const posST = cluster.subject_term_pos || [];
      const negST = cluster.subject_term_neg || [];
      
      // Get top positive policy areas and subject terms
      const topPA = posPA.slice(0, 2).map(pa => pa.name);
      const topST = posST.slice(0, 2).map(st => st.name);
      
      // Skip "Congressional Oversight" from subject terms
      let filteredST = topST.filter(st => 
        !st.toLowerCase().includes('congressional oversight')
      );
      if (filteredST.length === 0) {
        filteredST = topST; // Fall back to original if all were filtered
      }
      
      // Create a more descriptive characterization for clusters
      let description = '';
      
      if (topPA.length > 0 && filteredST.length > 0) {
        // Use the full policy area name and a clean subject term
        const pa = topPA[0];
        const st = filteredST[0];
        
        // Try to create a natural combination
        // If subject term is short enough, use it fully
        if (st.split(' ').length <= 4) {
          description = `${pa} & ${st}`;
        } else {
          // For longer subject terms, try to find a natural break point
          const stWords = st.split(' ');
          let cleanST = '';
          
          // Look for common break points (prepositions, conjunctions)
          const breakWords = ['and', 'or', 'of', 'in', 'on', 'at', 'for', 'with', 'by'];
          let breakIndex = -1;
          
          for (let i = 2; i < Math.min(4, stWords.length); i++) {
            if (breakWords.includes(stWords[i].toLowerCase())) {
              breakIndex = i;
              break;
            }
          }
          
          if (breakIndex > 0) {
            cleanST = stWords.slice(0, breakIndex).join(' ');
          } else {
            // Fall back to first 3 words if no natural break
            cleanST = stWords.slice(0, 3).join(' ');
          }
          
          description = `${pa} & ${cleanST}`;
        }
      } else if (topPA.length > 0) {
        // Just use policy area
        description = topPA[0];
      } else if (filteredST.length > 0) {
        // Just use subject term
        description = filteredST[0];
      } else {
        description = 'General voting pattern';
      }
      
      // Clean up the description
      description = description
        .replace(/[^a-zA-Z0-9\s&]/g, '') // Remove special characters except &
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      return description;
    }

    document.getElementById('refresh').addEventListener('click', () => {
      clearDescriptions();
      load();
    });
    document.getElementById('reset').addEventListener('click', () => {
      clearDescriptions();
      document.getElementById('subject').value = '';
      document.getElementById('policyArea').value = '';
      document.getElementById('subjectTerm').value = '';
      document.getElementById('scope').value = 'subject_term'; toggleSubjectInputs();
      document.getElementById('k').value = ''; // Clear k to trigger suggested k lookup
      document.getElementById('excludeProcedural').checked = true;
      document.getElementById('colorByParty').checked = true;
      document.getElementById('svdDims').value = '3'; // Reset to SVD(3) default
      updateMouseControlsInfo();
      load(true); // Use suggested k for reset
    });
    document.getElementById('generateReport').addEventListener('click', () => {
      const k = document.getElementById('k').value;
      const excludeProcedural = document.getElementById('excludeProcedural').checked;
      const scope = document.getElementById('scope').value;
      const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
      const svdDims = document.getElementById('svdDims').value;
      
      let url = `/clusters/report?k=${k}&exclude_procedural=${excludeProcedural}&svd_dims=${svdDims}`;
      if (subject) {
        url += `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}`;
      }
      window.open(url, '_blank');
    });
    document.getElementById('scope').addEventListener('change', () => {
      clearDescriptions();
      toggleSubjectInputs();
    });
    document.getElementById('colorByParty').addEventListener('change', () => {
      clearDescriptions();
      load();
    });
    document.getElementById('colorByCluster').addEventListener('change', () => {
      clearDescriptions();
      load();
    });
    document.getElementById('svdDims').addEventListener('change', ()=>{ 
      clearDescriptions();
      updateMouseControlsInfo();
      load(); // Reload to get new SVD components for the new dimensions
    });
    document.getElementById('k').addEventListener('change', () => {
      clearDescriptions();
      load();
    });
    document.getElementById('excludeProcedural').addEventListener('change', () => {
      clearDescriptions();
      load();
    });
    document.getElementById('btnSuggestK').addEventListener('click', async ()=>{
      clearDescriptions();
      const excludeProcedural = document.getElementById('excludeProcedural').checked;
      const scope = document.getElementById('scope').value;
      const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
      const url = `/api/clusters/auto-k?exclude_procedural=${excludeProcedural}` +
                  (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
      const res = await fetch(url);
      const pane = document.getElementById('k-metrics');
      if(!res.ok){ pane.textContent = 'Auto-k error'; return; }
      const data = await res.json();
      if (data.suggested_k){
        document.getElementById('k').value = String(data.suggested_k);
        // Show top 4 ks by silhouette
        const sorted = (data.metrics||[]).slice().sort((a,b)=>b.silhouette-a.silhouette).slice(0,4);
        pane.innerHTML = `Suggested k: <strong>${data.suggested_k}</strong> (silhouette ${(sorted[0]?.silhouette||0).toFixed(3)})<br>` +
          sorted.map(r=>`k=${r.k} — sil=${r.silhouette.toFixed(3)}, CH=${Math.round(r.calinski_harabasz)}, DB=${r.davies_bouldin.toFixed(2)}`).join('<br>');
        load();
      } else {
        pane.textContent = 'No suggestion available';
      }
    });

    document.getElementById('btnDescribeAxis').addEventListener('click', async ()=>{
      const dims = document.getElementById('svdDims').value;
      const axis = parseInt(document.getElementById('axisSelect').value,10);
      const excludeProcedural = document.getElementById('excludeProcedural').checked;
      const scope = document.getElementById('scope').value;
      const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
      const url = `/api/svd/components?dims=${dims}&exclude_procedural=${excludeProcedural}` +
                  (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
      const res = await fetch(url);
      const pane = document.getElementById('axis-summary');
      if(!res.ok){ pane.textContent = 'Axis summary error'; return; }
      const data = await res.json();
      const comps = data.components || [];
      const comp = comps[axis-1];
      if(!comp){ pane.textContent = 'No component data available'; return; }
      function listRC(rows){
        return rows.slice(0,5).map(r=>{
          const link = r.bill_id ? `<a href="/vote/${r.rollcall_id}" target="_blank">${r.rollcall_id}</a>` : r.rollcall_id;
          const bill = r.bill_id ? `<div class=\"text-muted\"><a href=\"/bill/${r.bill_id}\" target=\"_blank\">${r.title||r.bill_id}</a></div>` : '';
          const ps = r.party_split || {}; const d = ps.D||{}; const rr = ps.R||{};
          const split = (d.yea_pct!==undefined && rr.yea_pct!==undefined) ? ` D Yea ${d.yea_pct}% | R Yea ${rr.yea_pct}%` : '';
          return `<div class=\"mb-1\"><strong>${link}</strong> · w=${r.weight} ${split}<div>${r.question||''}</div>${bill}</div>`;
        }).join('');
      }
      function listKV(rows){ return rows.slice(0,5).map(x=>`${x.name} (${x.score.toFixed?x.score.toFixed(2):x.score})`).join(', '); }
      const characterization = generateAxisCharacterization(comp);
      const html = `
        <div><strong>Axis ${axis}</strong> <span class="badge bg-primary">${characterization}</span></div>
        <div class=\"mt-2\"><em>Top positive roll calls</em>${listRC(comp.top_rollcalls_pos)}</div>
        <div class=\"mt-2\"><em>Top negative roll calls</em>${listRC(comp.top_rollcalls_neg)}</div>
        <div class=\"mt-2\"><em>Policy areas</em><br>+ ${listKV(comp.policy_area_pos)}<br>- ${listKV(comp.policy_area_neg)}</div>
        <div class=\"mt-2\"><em>Subject terms</em><br>+ ${listKV(comp.subject_term_pos)}<br>- ${listKV(comp.subject_term_neg)}</div>
      `;
      pane.innerHTML = html;
    });

    document.getElementById('btnDescribeCluster').addEventListener('click', async ()=>{
      const excludeProcedural = document.getElementById('excludeProcedural').checked;
      const scope = document.getElementById('scope').value;
      const subject = scope === 'policy_area' ? document.getElementById('policyArea').value : document.getElementById('subjectTerm').value;
      const k = document.getElementById('k').value;
      const url = `/api/clusters/summary?exclude_procedural=${excludeProcedural}&k=${k}` +
                  (subject ? `&scope=${encodeURIComponent(scope)}&subject=${encodeURIComponent(subject)}` : '');
      const res = await fetch(url);
      const pane = document.getElementById('cluster-summary');
      if(!res.ok){ pane.textContent = 'Cluster summary error'; return; }
      const data = await res.json();
      const cid = parseInt(document.getElementById('clusterSelect').value,10) || 0;
      const c = (data.clusters||[]).find(x=>x.id===cid);
      if(!c){ pane.textContent = 'No data for this cluster'; return; }
      const party = c.party||{}; const cauc = c.caucuses||{};
      const states = (c.top_states||[]).map(s=>`${s.state} (${s.count})`).join(', ');
      const ex = (c.exemplars||[]).map(m=>`${m.name} (${m.party||''})`).join(', ');
      const edges = (c.edge_members||[]).map(m=>`${m.name} (${m.party||''})`).join(', ');
      function listKV(rows){ return (rows||[]).slice(0,6).map(x=>`${x.name} (${x.score})`).join(', '); }
      function rcList(rows){
        return (rows||[]).slice(0,5).map(r=>`<div class=\"mb-1\"><a href=\"/vote/${r.rollcall_id}\" target=\"_blank\">${r.rollcall_id}</a> · Δ=${r.delta} · ${r.question||''}<div class=\"text-muted\">${r.title||''}</div></div>`).join('');
      }
      pane.innerHTML = `
        <div><strong>Cluster ${c.id + 1}</strong> · size ${c.size} · party D ${party.D||0}, R ${party.R||0}, other ${party.other||0}</div>
        <div class="mt-1"><em>${generateClusterDescription(c)}</em></div>
        <div class=\"mt-2\">Top states: ${states||'-'}</div>
        <div class=\"mt-2\">Caucuses: FC ${cauc.fc}, PC ${cauc.pc}, BD ${cauc.bd}, MAGA ${cauc.maga}, CBC ${cauc.cbc}, TB ${cauc.tb}</div>
        <div class=\"mt-2\"><em>Policy areas</em><br>+ ${listKV(c.policy_area_pos)}<br>- ${listKV(c.policy_area_neg)}</div>
        <div class=\"mt-2\"><em>Subject terms</em><br>+ ${listKV(c.subject_term_pos)}<br>- ${listKV(c.subject_term_neg)}</div>
        <div class=\"mt-2\"><em>Anchor roll calls (largest Δ Yea% vs others)</em>${rcList(c.anchor_rollcalls)}</div>
        <div class=\"mt-2\"><em>Exemplars</em>: ${ex||'-'}</div>
        <div class=\"mt-2\"><em>Edge members</em>: ${edges||'-'}</div>
      `;
    });
    document.addEventListener('DOMContentLoaded', () => {
      toggleSubjectInputs();
      updateMouseControlsInfo();
      load(true); // Use suggested k for initial load
      // attach zoom/pan handlers
      const svg = document.getElementById('plot');
      // Wheel zoom around cursor
      svg.addEventListener('wheel', (e)=>{
        e.preventDefault();
        const rect = svg.getBoundingClientRect();
        const mx = (e.clientX - rect.left) / rect.width * VB_W;
        const my = (e.clientY - rect.top) / rect.height * VB_H;
        const factor = (e.deltaY < 0) ? 1.1 : 0.9;
        const newScale = Math.max(0.3, Math.min(20, zScale * factor));
        // keep point under cursor stationary: t' = t + (s - s') * p
        zTx = zTx + (zScale - newScale) * mx;
        zTy = zTy + (zScale - newScale) * my;
        zScale = newScale;
        updateTransform();
      }, { passive: false });
      // Mouse drag pan
      svg.addEventListener('mousedown', (e)=>{
        if (e.shiftKey){
          isRotating = true;
          rotLast.x = e.clientX; rotLast.y = e.clientY;
          svg.style.cursor = 'crosshair';
        } else {
          isPanning = true;
          panLast.x = e.clientX; panLast.y = e.clientY;
          svg.style.cursor = 'grabbing';
        }
      });
      window.addEventListener('mousemove', (e)=>{
        const svgEl = document.getElementById('plot');
        const rect = svgEl.getBoundingClientRect();
        if (isRotating){
          const dxPx = e.clientX - rotLast.x;
          const dyPx = e.clientY - rotLast.y;
          const S = 0.3; // deg per pixel
          yawDeg += dxPx * S;
          pitchDeg -= dyPx * S;
          // clamp pitch to avoid flipping
          if (pitchDeg > 89) pitchDeg = 89;
          if (pitchDeg < -89) pitchDeg = -89;
          rotLast.x = e.clientX; rotLast.y = e.clientY;
          // re-render with new projection
          render(currentItems);
          return;
        }
        if(!isPanning) return;
        const dxPx = e.clientX - panLast.x;
        const dyPx = e.clientY - panLast.y;
        // convert pixels to viewBox units (independent of scale, we pan in world coords)
        const dx = dxPx / rect.width * VB_W;
        const dy = dyPx / rect.height * VB_H;
        zTx += dx; zTy += dy;
        panLast.x = e.clientX; panLast.y = e.clientY;
        updateTransform();
      });
      window.addEventListener('mouseup', ()=>{ 
        if(isPanning){ isPanning=false; svg.style.cursor=''; }
        if(isRotating){ isRotating=false; svg.style.cursor=''; }
      });
      // Double click to reset
      svg.addEventListener('dblclick', ()=>{ zScale=1; zTx=0; zTy=0; yawDeg=35; pitchDeg=20; updateTransform(); render(currentItems); });

      // Touch/trackpad pinch-zoom and pan
      let pinchActive = false;
      let lastPinchDist = 0;
      function touchMidAndDist(touches){
        const rect = svg.getBoundingClientRect();
        const x1 = touches[0].clientX, y1 = touches[0].clientY;
        const x2 = touches[1].clientX, y2 = touches[1].clientY;
        const midXpx = (x1 + x2) / 2 - rect.left;
        const midYpx = (y1 + y2) / 2 - rect.top;
        const midX = (midXpx / rect.width) * VB_W;
        const midY = (midYpx / rect.height) * VB_H;
        const dx = x2 - x1, dy = y2 - y1;
        const dist = Math.hypot(dx, dy);
        return { midX, midY, dist };
      }
      svg.addEventListener('touchstart', (e)=>{
        if (e.touches.length === 1){
          // one-finger pan
          isPanning = true;
          panLast.x = e.touches[0].clientX; panLast.y = e.touches[0].clientY;
        } else if (e.touches.length >= 2){
          pinchActive = true;
          const info = touchMidAndDist(e.touches);
          lastPinchDist = info.dist;
        }
      }, { passive: false });
      svg.addEventListener('touchmove', (e)=>{
        if (pinchActive && e.touches.length >= 2){
          e.preventDefault();
          const info = touchMidAndDist(e.touches);
          if (lastPinchDist > 0){
            const factor = info.dist / lastPinchDist;
            const newScale = Math.max(0.3, Math.min(20, zScale * factor));
            zTx = zTx + (zScale - newScale) * info.midX;
            zTy = zTy + (zScale - newScale) * info.midY;
            zScale = newScale;
            updateTransform();
          }
          lastPinchDist = info.dist;
        } else if (isPanning && e.touches.length === 1){
          e.preventDefault();
          const rect = svg.getBoundingClientRect();
          const dxPx = e.touches[0].clientX - panLast.x;
          const dyPx = e.touches[0].clientY - panLast.y;
          const dx = dxPx / rect.width * VB_W;
          const dy = dyPx / rect.height * VB_H;
          zTx += dx; zTy += dy;
          panLast.x = e.touches[0].clientX; panLast.y = e.touches[0].clientY;
          updateTransform();
        }
      }, { passive: false });
      function endTouches(){ pinchActive=false; lastPinchDist=0; isPanning=false; svg.style.cursor=''; }
      svg.addEventListener('touchend', endTouches);
      svg.addEventListener('touchcancel', endTouches);
    });
  </script>
</body>
</html>
